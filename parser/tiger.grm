structure A = Absyn
val sym = Symbol.symbolize
type symbol = Symbol.symbol
val name = Symbol.name
type recordFieldsT = ((symbol * A.exp * A.pos) list)
			 
%%
%term
    EOF 
  | ID of string
  | INT of int | STRING of string 
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK 
  | LBRACE | RBRACE | DOT 
  | PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF 
  | BREAK | NIL
  | FUNCTION | VAR | TYPE
  | UMINUS | LOWERTHANOPHACK
    
%nonterm  program of A.exp | expr of A.exp
	| lvalue of A.var | exprSeq of (A.exp * A.pos) list
	| funparam of A.exp list
	| record of A.exp
	| recordFields of recordFieldsT
	| decs of A.dec list
	| tydec of {name:symbol, ty:A.ty, pos:A.pos}
	| tydecs of {name:symbol, ty:A.ty, pos:A.pos} list
	| ty of A.ty
	| tyfields of A.field list
	  (* | tyfields of (sym * bool ref * sym * pos) list *)
	| vardec of A.dec
	| fundec of A.fundec | fundecs of A.fundec list
	  

%pos Absyn.pos
%verbose
%start program
%eop EOF
%noshift EOF

		(* Define associativity and precedence *)
%nonassoc LOWERTHANOPHACK
%nonassoc ASSIGN
%left OR
%left AND
%nonassoc EQ NEQ LT LE GT GE
%left MINUS PLUS
%left TIMES DIVIDE
%left UMINUS

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

%%

program	: expr  (expr)

expr : lvalue (A.VarExp(lvalue))
		(* NilExp, IntExp, StringExp, CallExp *)
     | NIL (A.NilExp)
     | INT (A.IntExp(INT))
     | STRING (A.StringExp(STRING, STRINGleft))
     | ID LPAREN funparam RPAREN (A.CallExp({func=sym(ID),
					    args=funparam,
					    pos=IDleft}))
		(* OpExp *)
     | MINUS expr   %prec UMINUS (A.OpExp({left=A.IntExp(0),
					  oper=A.MinusOp,
					  right=expr, pos=exprleft}))
     | expr TIMES expr (A.OpExp({left=expr1,
				oper=A.TimesOp,
				right=expr2, pos=TIMESleft}))
     | expr PLUS expr (A.OpExp({left=expr1,
				oper=A.PlusOp,
				right=expr2, pos=PLUSleft}))
     | expr MINUS expr (A.OpExp({left=expr1,
				oper=A.MinusOp,
				right=expr2, pos=MINUSleft}))
     | expr DIVIDE expr (A.OpExp({left=expr1,
				oper=A.DivideOp,
				right=expr2, pos=DIVIDEleft}))
     | expr EQ expr (A.OpExp({left=expr1,
				oper=A.EqOp,
				right=expr2, pos=EQleft}))
     | expr NEQ expr (A.OpExp({left=expr1,
				oper=A.NeqOp,
				right=expr2, pos=NEQleft}))
     | expr LT expr (A.OpExp({left=expr1,
				oper=A.LtOp,
				right=expr2, pos=LTleft}))
     | expr LE expr (A.OpExp({left=expr1,
				oper=A.LeOp,
				right=expr2, pos=LEleft}))
     | expr GT expr (A.OpExp({left=expr1,
				oper=A.GtOp,
				right=expr2, pos=GTleft}))
     | expr GE expr (A.OpExp({left=expr1,
			     oper=A.GeOp,
			     right=expr2, pos=GEleft}))
     | expr AND expr (A.IfExp({test=expr1, then'=expr2, else'=SOME(A.IntExp(0)), pos=ANDleft}))
     | expr OR expr (A.IfExp({test=expr1, then'=A.IntExp(1), else'=SOME(expr2), pos=ORleft}))
		(* RecordExp, SeqExp, AssingExp *)
     | record (record)
     | LPAREN RPAREN (A.SeqExp([]))
     | LPAREN expr RPAREN (A.SeqExp([(expr, exprleft)]))
     | LPAREN exprSeq RPAREN (A.SeqExp(exprSeq))
     | lvalue ASSIGN expr (A.AssignExp({var=lvalue, exp=expr, pos=ASSIGNleft}))
		(* IfExp, WhileExp, ForExp, BreakExp *)
     | IF expr THEN expr %prec LOWERTHANOPHACK (A.IfExp({test=expr1,
							then'=expr2,
							else'=NONE,
							pos=IFleft}))
     | IF expr THEN expr ELSE expr %prec LOWERTHANOPHACK (A.IfExp({test=expr1, then'=expr2, else'=SOME(expr3), pos=IFleft}))
     | WHILE expr DO expr %prec LOWERTHANOPHACK (A.WhileExp({test=expr1, body=expr2, pos=WHILEleft}))
     | FOR ID ASSIGN expr TO expr DO expr %prec LOWERTHANOPHACK (A.ForExp({var=sym(ID), escape=ref true, lo=expr1, hi=expr2, body=expr3, pos=FORleft}))
     | BREAK (A.BreakExp(BREAKleft))
		(* LetExp *)
     | LET decs IN END (A.LetExp({decs=decs, body=A.SeqExp([]),
				 pos=LETleft}))
     | LET decs IN expr END (A.LetExp({decs=decs,
				      body=expr, pos=LETleft}))
     | LET decs IN exprSeq END (A.LetExp({decs=decs,
					 body=A.SeqExp(exprSeq),
					 pos=LETleft}))
		(* ArrayExp *)
     | ID LBRACK expr RBRACK OF expr %prec LOWERTHANOPHACK (
	   A.ArrayExp({typ=sym(ID), size=expr1, init=expr2, pos=IDleft}))
	  
(* SimpleVar, FieldVar, SubscriptVar *)
lvalue : ID (A.SimpleVar(sym(ID), IDleft))
       | lvalue DOT ID (A.FieldVar(lvalue, sym(ID), DOTleft))
       | ID LBRACK expr RBRACK (A.SubscriptVar(A.SimpleVar(sym(ID),
							   IDleft),
					       expr, LBRACKleft))
       | lvalue LBRACK expr RBRACK (A.SubscriptVar(lvalue,
						   expr, LBRACKleft))

(* Helper for SeqExp *)
exprSeq : expr SEMICOLON expr ([(expr1, expr1left), (expr2, expr2left)])
	| exprSeq SEMICOLON expr (exprSeq@[(expr, exprleft)])
		
(* Helper for CallExp *)
funparam : 			(* empty call *) ([])
	| expr ([expr])
	| funparam COMMA expr (funparam@[expr])

(* Helper for RecordExp *)
record : ID LBRACE RBRACE (A.RecordExp({fields=[], typ=sym(ID),
				       pos=IDleft}))
       | ID LBRACE recordFields RBRACE (A.RecordExp({fields=recordFields,
						    typ=sym(ID),
						    pos=IDleft}))

(* Helper for record *)
recordFields : ID EQ expr ([(sym(ID), expr, EQleft)])
	     | recordFields COMMA ID EQ expr (recordFields@[(sym(ID), expr, EQleft)])


(* Decs *)
decs: 			([])	(* empty *)
    | decs tydecs (decs@[A.TypeDec(tydecs)])
    | decs vardec (decs@[vardec])
    | decs fundecs (decs@[A.FunctionDec(fundecs)])
	  
(* TypeDec: helper for decs *)
tydecs : tydec ([tydec])
       | tydecs tydec  (tydecs@[tydec])
tydec : TYPE ID EQ ty ({name=sym(ID), ty=ty, pos=EQleft})

(* Ty, Helper for TypeDec. NameTy, RecordTy, ArrayTy *)
ty : ID (A.NameTy(sym(ID), IDleft))
   | LBRACE tyfields RBRACE (A.RecordTy(tyfields))
   | ARRAY OF ID (A.ArrayTy(sym(ID), IDleft))

(* Helper for Ty. *)
tyfields :	 ([])		(* epsilon *)
   | ID COLON ID  ([{name=sym(ID1),
		     escape=ref true,
		     typ=sym(ID2),
		     pos=COLONleft}])
   | tyfields COMMA ID COLON ID  (tyfields@[{name=sym(ID1),
					     escape=ref true,
					     typ=sym(ID2),
					     pos=COLONleft}])

(* FunctionDec, helper for Dec(s) *)
fundecs : fundec ([fundec])
	| fundecs fundec (fundecs@[fundec])

fundec : FUNCTION ID LPAREN tyfields RPAREN EQ expr ({name=sym(ID),
						      params=tyfields,
						      result=NONE,
						      body=expr,
						      pos=IDleft})
       | FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ expr (
	     {name=sym(ID1),
	      params=tyfields,
	      result=SOME((sym(ID2), ID2left)),
	      body=expr, pos=ID1left})

(* VarDec, a helper for Dec(s) *)
vardec : VAR ID ASSIGN expr (A.VarDec({name=sym(ID), escape=ref true,
				       typ=NONE, init=expr,
				       pos=ASSIGNleft}))
       | VAR ID COLON ID ASSIGN expr (A.VarDec({name=sym(ID1),
						escape=ref true,
						typ=SOME((sym(ID2),
							  COLONleft)),
						init=expr,
						pos=ASSIGNleft}))
